using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Security.Cryptography;
using System.Text;
using CFramework.Core.Editor.Base;
using CFramework.Core.Editor.Utilities;
using CNoom.UnityCodeGen.Editor;
using UnityEditor;
using UnityEditor.AddressableAssets;
using UnityEditor.AddressableAssets.Settings;
using UnityEngine;

namespace CFramework.Editor.AddressablesTools
{
    public static class AddressablesCodeGen
    {

        private const string GeneratedFileMarker = "// Auto-generated by CFramework AddressablesCodeGen";
        private const int MaxIdentifierLength = 50;
        private static readonly string[] BuiltInGroupNames =
        {
            "Built In Data",
            "Built_In_Data"
        };

        public static void Generate(AddressableConfig reg)
        {
            AddressableAssetSettings settings = AddressableAssetSettingsDefaultObject.Settings;
            if(!settings)
                throw new InvalidOperationException("未找到 AddressableAssetSettings，请先在 Addressables 窗口创建设置。");

            string ns = string.IsNullOrWhiteSpace(reg.codeGenNamespace) ? "CFramework.Addressables" : reg.codeGenNamespace;
            string className = string.IsNullOrWhiteSpace(reg.codeGenClassName) ? "AddressKeys" : reg.codeGenClassName;
            string labelsClassName = className + "Labels";
            string outputPath = CFDirectoryKey.FrameworkGenerate;
            List<string> overridePaths = reg.records
                .Select(r => r.codeGenOutputPathOverride)
                .Where(p => !string.IsNullOrWhiteSpace(p))
                .Distinct(StringComparer.OrdinalIgnoreCase)
                .ToList();
            if(overridePaths.Count == 1)
            {
                outputPath = overridePaths[0];
            }
            else if(overridePaths.Count > 1)
            {
                Debug.LogWarning("[CFramework][Addressables][CodeGen] 检测到多个不同的输出路径覆盖，已忽略并使用默认输出路径。");
            }

            Dictionary<string, string> generatedFileHashes = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
            SortedDictionary<string, List<AddressableAssetEntry>> groupToEntries = CollectGroupEntries(settings);

            switch(reg.codeGenStructure)
            {
                case CodeGenStructure.SingleClass:
                    GenerateSingleClass(outputPath, ns, className, groupToEntries, generatedFileHashes);
                    break;
                case CodeGenStructure.NestedByGroup:
                    GenerateNestedByGroup(outputPath, ns, className, groupToEntries, generatedFileHashes);
                    break;
                case CodeGenStructure.SplitFilesByGroup:
                    GenerateSplitFilesByGroup(outputPath, ns, className, groupToEntries, generatedFileHashes);
                    break;
                default:
                    GenerateNestedByGroup(outputPath, ns, className, groupToEntries, generatedFileHashes);
                    break;
            }

            List<string> allLabels = settings.GetLabels()?.ToList() ?? new List<string>();
            GenerateLabelsClass(outputPath, ns, labelsClassName, allLabels, generatedFileHashes);
            CleanupObsoleteGeneratedFiles(outputPath, className, labelsClassName, generatedFileHashes);

            AssetDatabase.Refresh();
        }

        private static SortedDictionary<string, List<AddressableAssetEntry>> CollectGroupEntries(
            AddressableAssetSettings settings)
        {
            SortedDictionary<string, List<AddressableAssetEntry>> groupToEntries =
                new SortedDictionary<string, List<AddressableAssetEntry>>(StringComparer.OrdinalIgnoreCase);
            foreach (AddressableAssetGroup g in settings.groups.Where(g => g))
            {
                if(IsBuiltInGroup(g))
                {
                    continue;
                }

                List<AddressableAssetEntry> list = g.entries?.ToList() ?? new List<AddressableAssetEntry>();
                if(!groupToEntries.ContainsKey(g.Name)) groupToEntries[g.Name] = new List<AddressableAssetEntry>();
                groupToEntries[g.Name].AddRange(list);
            }

            return groupToEntries;
        }

        private static List<Dictionary<string, object>> PrepareGroupData(
            SortedDictionary<string, List<AddressableAssetEntry>> groups,
            bool shareUsedNames = false)
        {
            List<Dictionary<string, object>> result = new List<Dictionary<string, object>>();
            HashSet<string> globalKeywords = IdentifierUtility.CSharpKeywords;
            HashSet<string> sharedUsedNames = shareUsedNames ? new HashSet<string>(StringComparer.OrdinalIgnoreCase) : null;

            foreach (KeyValuePair<string, List<AddressableAssetEntry>> kv in groups)
            {
                string groupClass = SanitizeIdentifierLength(kv.Key, s => IdentifierUtility.ToTypeIdentifier(s));
                HashSet<string> usedNames = sharedUsedNames ?? new HashSet<string>(StringComparer.OrdinalIgnoreCase);
                List<Dictionary<string, object>> entries = new List<Dictionary<string, object>>();

                foreach (AddressableAssetEntry e in kv.Value.OrderBy(e => e.address, StringComparer.Ordinal))
                {
                    string unique = GenerateUniqueIdentifier(e.address, globalKeywords, usedNames);
                    entries.Add(new Dictionary<string, object>
                    {
                        {
                            "Address", e.address
                        },
                        {
                            "Identifier", unique
                        }
                    });
                }

                result.Add(new Dictionary<string, object>
                {
                    {
                        "GroupName", kv.Key
                    },
                    {
                        "GroupClassName", groupClass
                    },
                    {
                        "Entries", entries
                    }
                });
            }

            return result;
        }

        private static void GenerateSingleClass(string outputDir, string ns, string className,
            SortedDictionary<string, List<AddressableAssetEntry>> groups, Dictionary<string, string> generatedFileHashes)
        {
            string file = Path.Combine(outputDir, className + ".cs");
            CodeGenTemplate template = new CodeGenTemplate("SingleClass", Templates.TemplateSingleClass);
            CodeGenContext context = new CodeGenContext()
                .Set("Namespace", ns)
                .Set("ClassName", className)
                .Set("Groups", PrepareGroupData(groups));

            CodeGenRequest request = new CodeGenRequest
            {
                OutputPath = file,
                Template = template,
                Context = context,
                WriteMode = CodeGenWriteMode.Overwrite
            };

            string content = CodeGen.Render(request.Template, request.Context);
            string hash = ComputeHash(content);
            CodeGenUtility.WriteIfChanged(file, content);
            TrackGeneratedFile(file, hash, generatedFileHashes);
        }

        private static void GenerateNestedByGroup(string outputDir, string ns, string className,
            SortedDictionary<string, List<AddressableAssetEntry>> groups, Dictionary<string, string> generatedFileHashes)
        {
            string file = Path.Combine(outputDir, className + ".cs");
            CodeGenTemplate template =
                new CodeGenTemplate("NestedByGroup", Templates.TemplateNestedByGroup);
            CodeGenContext context = new CodeGenContext()
                .Set("Namespace", ns)
                .Set("ClassName", className)
                .Set("Groups", PrepareGroupData(groups));

            CodeGenRequest request = new CodeGenRequest
            {
                OutputPath = file,
                Template = template,
                Context = context,
                WriteMode = CodeGenWriteMode.Overwrite
            };

            string content = CodeGen.Render(request.Template, request.Context);
            string hash = ComputeHash(content);
            CodeGenUtility.WriteIfChanged(file, content);
            TrackGeneratedFile(file, hash, generatedFileHashes);
        }

        private static void GenerateSplitFilesByGroup(string outputDir, string ns, string className,
            SortedDictionary<string, List<AddressableAssetEntry>> groups, Dictionary<string, string> generatedFileHashes)
        {
            foreach (KeyValuePair<string, List<AddressableAssetEntry>> kv in groups)
            {
                string groupClass = SanitizeIdentifierLength(kv.Key, s => IdentifierUtility.ToTypeIdentifier(s));
                string file = Path.Combine(outputDir, $"{className}_{groupClass}.cs");
                HashSet<string> usedNames = new HashSet<string>(StringComparer.OrdinalIgnoreCase);
                List<Dictionary<string, object>> entries = new List<Dictionary<string, object>>();

                foreach (AddressableAssetEntry e in kv.Value.OrderBy(e => e.address, StringComparer.Ordinal))
                {
                    string unique = GenerateUniqueIdentifier(e.address, IdentifierUtility.CSharpKeywords, usedNames);
                    entries.Add(new Dictionary<string, object>
                    {
                        {
                            "Address", e.address
                        },
                        {
                            "Identifier", unique
                        }
                    });
                }

                CodeGenTemplate template =
                    new CodeGenTemplate("SplitByGroup", Templates.TemplateSplitByGroup);
                CodeGenContext context = new CodeGenContext()
                    .Set("Namespace", ns)
                    .Set("ClassName", className)
                    .Set("GroupClassName", groupClass)
                    .Set("Entries", entries);

                string content = CodeGen.Render(template, context);
                string hash = ComputeHash(content);
                CodeGenUtility.WriteIfChanged(file, content);
                TrackGeneratedFile(file, hash, generatedFileHashes);
            }
        }

        private static void GenerateLabelsClass(string outputDir, string ns, string labelsClassName,
            List<string> labels, Dictionary<string, string> generatedFileHashes)
        {
            string file = Path.Combine(outputDir, labelsClassName + ".cs");
            HashSet<string> usedNames = new HashSet<string>(StringComparer.OrdinalIgnoreCase);
            List<Dictionary<string, object>> labelList = new List<Dictionary<string, object>>();

            foreach (string label in labels.OrderBy(l => l, StringComparer.Ordinal))
            {
                if(string.IsNullOrWhiteSpace(label)) continue;
                string unique = GenerateUniqueIdentifier(label, IdentifierUtility.CSharpKeywords, usedNames);
                labelList.Add(new Dictionary<string, object>
                {
                    {
                        "Label", label
                    },
                    {
                        "Identifier", unique
                    }
                });
            }

            CodeGenTemplate template = new CodeGenTemplate("Labels", Templates.TemplateLabels);
            CodeGenContext context = new CodeGenContext()
                .Set("Namespace", ns)
                .Set("ClassName", labelsClassName)
                .Set("Labels", labelList);

            string content = CodeGen.Render(template, context);
            string hash = ComputeHash(content);
            CodeGenUtility.WriteIfChanged(file, content);
            TrackGeneratedFile(file, hash, generatedFileHashes);
        }

        private static bool IsBuiltInGroup(AddressableAssetGroup group)
        {
            if(group == null)
            {
                return false;
            }

            return BuiltInGroupNames.Any(name =>
                string.Equals(group.Name, name, StringComparison.OrdinalIgnoreCase));
        }

        private static void CleanupObsoleteGeneratedFiles(string outputDir, string className, string labelsClassName,
            Dictionary<string, string> generatedFileHashes)
        {
            if(string.IsNullOrWhiteSpace(outputDir) || !Directory.Exists(outputDir))
            {
                return;
            }

            Dictionary<string, string> trackedFiles = generatedFileHashes ?? new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);

            foreach (string file in Directory.GetFiles(outputDir, "*.cs", SearchOption.TopDirectoryOnly))
            {
                if(!IsAddressablesGeneratedFile(file, className, labelsClassName))
                {
                    continue;
                }

                string normalizedFile = Path.GetFullPath(file);
                if(trackedFiles.ContainsKey(normalizedFile))
                {
                    continue;
                }

                if(IsFileManuallyModified(file))
                {
                    Debug.LogWarning($"[CFramework][Addressables][CodeGen] 跳过手动修改的文件：{file}");
                    continue;
                }

                try
                {
                    File.Delete(file);
                    Debug.Log($"[CFramework][Addressables][CodeGen] 已删除过时的生成文件：{file}");
                }
                catch (Exception ex)
                {
                    Debug.LogWarning($"删除旧的 Addressables 常量文件失败：{file}\n{ex}");
                }
            }
        }

        private static bool IsAddressablesGeneratedFile(string filePath, string className, string labelsClassName)
        {
            string fileName = Path.GetFileNameWithoutExtension(filePath);
            if(string.IsNullOrWhiteSpace(fileName))
            {
                return false;
            }

            if(!string.IsNullOrWhiteSpace(className))
            {
                if(fileName.Equals(className, StringComparison.OrdinalIgnoreCase) ||
                   fileName.StartsWith(className + "_", StringComparison.OrdinalIgnoreCase) ||
                   fileName.StartsWith(className + ".", StringComparison.OrdinalIgnoreCase))
                {
                    return true;
                }
            }

            return !string.IsNullOrWhiteSpace(labelsClassName) &&
                   fileName.Equals(labelsClassName, StringComparison.OrdinalIgnoreCase);
        }

        private static bool IsFileManuallyModified(string filePath)
        {
            try
            {
                if(!File.Exists(filePath))
                {
                    return false;
                }

                string content = File.ReadAllText(filePath);
                return !content.Contains(GeneratedFileMarker);
            }
            catch (Exception)
            {
                return false;
            }
        }

        private static void TrackGeneratedFile(string filePath, string contentHash, Dictionary<string, string> generatedFileHashes)
        {
            if(generatedFileHashes == null || string.IsNullOrWhiteSpace(filePath))
            {
                return;
            }

            try
            {
                string normalizedPath = Path.GetFullPath(filePath);
                generatedFileHashes[normalizedPath] = contentHash;
            }
            catch (Exception)
            {
                generatedFileHashes[filePath] = contentHash;
            }
        }

        private static string ComputeHash(string content)
        {
            using SHA256 sha256 = SHA256.Create();
            byte[] bytes = Encoding.UTF8.GetBytes(content);
            byte[] hash = sha256.ComputeHash(bytes);
            return BitConverter.ToString(hash).Replace("-", "");
        }

        private static string SanitizeIdentifierLength(string original, Func<string, string> toIdentifierFunc)
        {
            string identifier = toIdentifierFunc(original);
            if(identifier.Length <= MaxIdentifierLength)
            {
                return identifier;
            }

            string hashSuffix = ComputeHash(original).Substring(0, 8);
            int prefixLength = MaxIdentifierLength - hashSuffix.Length - 1;
            if(prefixLength < 5)
            {
                prefixLength = 5;
            }

            return identifier.Substring(0, prefixLength) + "_" + hashSuffix;
        }

        private static string GenerateUniqueIdentifier(string input, HashSet<string> keywords,
            HashSet<string> usedNames)
        {
            string desired = IdentifierUtility.ToIdentifier(input);
            if(keywords.Contains(desired)) desired = "_" + desired;
            return IdentifierUtility.MakeUnique(desired, usedNames);
        }
    }
}